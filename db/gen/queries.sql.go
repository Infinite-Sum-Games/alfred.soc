// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addIssueTagQuery = `-- name: AddIssueTagQuery :one
UPDATE issues
SET tags = array_append(tags, $1),
    updated_at = NOW()
WHERE url = $2
RETURNING tags
`

type AddIssueTagQueryParams struct {
	ArrayAppend interface{} `json:"array_append"`
	Url         string      `json:"url"`
}

func (q *Queries) AddIssueTagQuery(ctx context.Context, db DBTX, arg AddIssueTagQueryParams) ([]string, error) {
	row := db.QueryRow(ctx, addIssueTagQuery, arg.ArrayAppend, arg.Url)
	var tags []string
	err := row.Scan(&tags)
	return tags, err
}

const addNewIssueQuery = `-- name: AddNewIssueQuery :exec
INSERT INTO issues (title, repoUrl, url)
VALUES ($1, $2, $3)
`

type AddNewIssueQueryParams struct {
	Title   string `json:"title"`
	Repourl string `json:"repourl"`
	Url     string `json:"url"`
}

func (q *Queries) AddNewIssueQuery(ctx context.Context, db DBTX, arg AddNewIssueQueryParams) error {
	_, err := db.Exec(ctx, addNewIssueQuery, arg.Title, arg.Repourl, arg.Url)
	return err
}

const addSolutionQuery = `-- name: AddSolutionQuery :one
INSERT INTO solutions (url, repo_url, ghUsername)
VALUES ($1, $2, $3)
RETURNING url
`

type AddSolutionQueryParams struct {
	Url        string `json:"url"`
	RepoUrl    string `json:"repo_url"`
	Ghusername string `json:"ghusername"`
}

func (q *Queries) AddSolutionQuery(ctx context.Context, db DBTX, arg AddSolutionQueryParams) (string, error) {
	row := db.QueryRow(ctx, addSolutionQuery, arg.Url, arg.RepoUrl, arg.Ghusername)
	var url string
	err := row.Scan(&url)
	return url, err
}

const checkIfSolutionExist = `-- name: CheckIfSolutionExist :one
SELECT
    id
FROM
    solutions
WHERE
    url = $1
`

func (q *Queries) CheckIfSolutionExist(ctx context.Context, db DBTX, url string) (int32, error) {
	row := db.QueryRow(ctx, checkIfSolutionExist, url)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const checkIfTagExistInIssueQuery = `-- name: CheckIfTagExistInIssueQuery :one
SELECT EXISTS (
  SELECT 1
  FROM issues
  WHERE tags @> ARRAY[$1]::text[]
  AND url = $2
) AS tag_exists
`

type CheckIfTagExistInIssueQueryParams struct {
	Column1 []string `json:"column_1"`
	Url     string   `json:"url"`
}

func (q *Queries) CheckIfTagExistInIssueQuery(ctx context.Context, db DBTX, arg CheckIfTagExistInIssueQueryParams) (bool, error) {
	row := db.QueryRow(ctx, checkIfTagExistInIssueQuery, arg.Column1, arg.Url)
	var tag_exists bool
	err := row.Scan(&tag_exists)
	return tag_exists, err
}

const checkOpenIssueQuery = `-- name: CheckOpenIssueQuery :one
SELECT EXISTS(
  SELECT 1 FROM issues
  WHERE url = $1
) AS found
`

func (q *Queries) CheckOpenIssueQuery(ctx context.Context, db DBTX, url string) (bool, error) {
	row := db.QueryRow(ctx, checkOpenIssueQuery, url)
	var found bool
	err := row.Scan(&found)
	return found, err
}

const closeIssueQuery = `-- name: CloseIssueQuery :one
UPDATE issues
SET
    resolved = TRUE,
    updated_at = NOW()
WHERE
    url = $1
RETURNING url
`

func (q *Queries) CloseIssueQuery(ctx context.Context, db DBTX, url string) (string, error) {
	row := db.QueryRow(ctx, closeIssueQuery, url)
	err := row.Scan(&url)
	return url, err
}

const extendClaimQuery = `-- name: ExtendClaimQuery :one
UPDATE issue_claims
SET
    elapsed_on = elapsed_on + make_interval(days => $1)
WHERE
    ghUsername = $2 
    AND issue_url = $3
    AND elapsed_on > NOW()
returning ghUsername
`

type ExtendClaimQueryParams struct {
	Days       int32  `json:"days"`
	Ghusername string `json:"ghusername"`
	IssueUrl   string `json:"issue_url"`
}

func (q *Queries) ExtendClaimQuery(ctx context.Context, db DBTX, arg ExtendClaimQueryParams) (string, error) {
	row := db.QueryRow(ctx, extendClaimQuery, arg.Days, arg.Ghusername, arg.IssueUrl)
	var ghusername string
	err := row.Scan(&ghusername)
	return ghusername, err
}

const getMaintainersQuery = `-- name: GetMaintainersQuery :one
SELECT maintainers FROM repository
WHERE url = $1
`

func (q *Queries) GetMaintainersQuery(ctx context.Context, db DBTX, url string) ([]string, error) {
	row := db.QueryRow(ctx, getMaintainersQuery, url)
	var maintainers []string
	err := row.Scan(&maintainers)
	return maintainers, err
}

const issueAssignQuery = `-- name: IssueAssignQuery :exec
INSERT INTO issue_claims (
    ghUsername,
    issue_url,
    claimed_on,
    elapsed_on
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type IssueAssignQueryParams struct {
	Ghusername string           `json:"ghusername"`
	IssueUrl   string           `json:"issue_url"`
	ClaimedOn  pgtype.Timestamp `json:"claimed_on"`
	ElapsedOn  pgtype.Timestamp `json:"elapsed_on"`
}

func (q *Queries) IssueAssignQuery(ctx context.Context, db DBTX, arg IssueAssignQueryParams) error {
	_, err := db.Exec(ctx, issueAssignQuery,
		arg.Ghusername,
		arg.IssueUrl,
		arg.ClaimedOn,
		arg.ElapsedOn,
	)
	return err
}

const issueUnassignQuery = `-- name: IssueUnassignQuery :one
DELETE FROM issue_claims
WHERE
    ghUsername = $1 AND issue_url = $2 AND elapsed_on > NOW()
RETURNING ghUsername
`

type IssueUnassignQueryParams struct {
	Ghusername string `json:"ghusername"`
	IssueUrl   string `json:"issue_url"`
}

func (q *Queries) IssueUnassignQuery(ctx context.Context, db DBTX, arg IssueUnassignQueryParams) (string, error) {
	row := db.QueryRow(ctx, issueUnassignQuery, arg.Ghusername, arg.IssueUrl)
	var ghusername string
	err := row.Scan(&ghusername)
	return ghusername, err
}

const mergeSolutionQuery = `-- name: MergeSolutionQuery :one
UPDATE solutions
SET
    is_merged = true,
    updated_at = NOW()
WHERE
    url = $1
RETURNING url
`

func (q *Queries) MergeSolutionQuery(ctx context.Context, db DBTX, url string) (string, error) {
	row := db.QueryRow(ctx, mergeSolutionQuery, url)
	err := row.Scan(&url)
	return url, err
}

const openIssueQuery = `-- name: OpenIssueQuery :one
UPDATE issues
SET
    resolved = FALSE,
    updated_at = NOW()
WHERE
    url = $1
RETURNING url
`

func (q *Queries) OpenIssueQuery(ctx context.Context, db DBTX, url string) (string, error) {
	row := db.QueryRow(ctx, openIssueQuery, url)
	err := row.Scan(&url)
	return url, err
}

const participantExistsQuery = `-- name: ParticipantExistsQuery :one
SELECT EXISTS (
  SELECT 1 FROM user_account 
  WHERE ghUsername = $1
  AND status = true
) AS found
`

func (q *Queries) ParticipantExistsQuery(ctx context.Context, db DBTX, ghusername pgtype.Text) (bool, error) {
	row := db.QueryRow(ctx, participantExistsQuery, ghusername)
	var found bool
	err := row.Scan(&found)
	return found, err
}

const updateIssueDifficultyQuery = `-- name: UpdateIssueDifficultyQuery :one
UPDATE issues
SET 
  difficulty = $1
WHERE url = $2
RETURNING url
`

type UpdateIssueDifficultyQueryParams struct {
	Difficulty string `json:"difficulty"`
	Url        string `json:"url"`
}

func (q *Queries) UpdateIssueDifficultyQuery(ctx context.Context, db DBTX, arg UpdateIssueDifficultyQueryParams) (string, error) {
	row := db.QueryRow(ctx, updateIssueDifficultyQuery, arg.Difficulty, arg.Url)
	var url string
	err := row.Scan(&url)
	return url, err
}

const updateRepositoryOnDisplayQuery = `-- name: UpdateRepositoryOnDisplayQuery :one
UPDATE repository
SET on_display = TRUE
WHERE url = $1
RETURNING name
`

func (q *Queries) UpdateRepositoryOnDisplayQuery(ctx context.Context, db DBTX, url string) (string, error) {
	row := db.QueryRow(ctx, updateRepositoryOnDisplayQuery, url)
	var name string
	err := row.Scan(&name)
	return name, err
}

const verifyRepositoryQuery = `-- name: VerifyRepositoryQuery :one
UPDATE repository 
  SET linked = TRUE
  WHERE url = $1
RETURNING name
`

func (q *Queries) VerifyRepositoryQuery(ctx context.Context, db DBTX, url string) (string, error) {
	row := db.QueryRow(ctx, verifyRepositoryQuery, url)
	var name string
	err := row.Scan(&name)
	return name, err
}
